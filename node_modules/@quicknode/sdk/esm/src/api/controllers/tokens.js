import { __decorate, __metadata } from 'tslib';
import { DEFAULT_CHAIN } from '../utils/constants.js';
import { balancesByWalletAddressValidator } from '../types/tokens/getBalancesByWalletAddress.js';
import { CodegenEthMainnetBalancesByWalletENSDocument, CodegenEthMainnetBalancesByWalletAddressDocument } from '../graphql/generatedTypes.js';
import { emptyPageInfo } from '../utils/helpers.js';
import { formatQueryResult } from '../utils/postQueryFormatter.js';
import { isValidENSAddress } from '../utils/isValidENSAddress.js';
import { ValidateInput } from '../../lib/validation/ValidateInput.js';
import { modifyQueryForChain } from '../graphql/modifyQueryForChain.js';

class TokensController {
    constructor(client, defaultChain = DEFAULT_CHAIN) {
        this.client = client;
        this.defaultChain = defaultChain;
    }
    async getBalancesByWallet(variables) {
        const { address, ...allVariables } = variables;
        if (isValidENSAddress(address)) {
            return this.getBalancesByWalletENS({
                ensName: address,
                ...allVariables,
            });
        }
        return this.getBalancesByWalletAddress({
            address,
            ...allVariables,
        });
    }
    async getBalancesByWalletENS(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetBalancesByWalletENSDocument);
        const result = await this.client.query({
            variables: queryVariables,
            query: query,
        });
        const walletByENS = result?.data?.[userChain]?.walletByENS;
        if (!walletByENS?.tokenBalances?.length) {
            // Address can still be valid ENS name, but not have any balances
            const address = walletByENS?.address || '';
            const ensName = walletByENS?.ensName || '';
            return {
                address: address,
                ensName: ensName,
                results: [],
                pageInfo: emptyPageInfo,
            };
        }
        const formattedResult = formatQueryResult(walletByENS, 'tokenBalances', 'tokenBalancesPageInfo', null, this.flattenBalanceResponses // Remove the "contract" key and move info to balance result body
        );
        return formattedResult;
    }
    async getBalancesByWalletAddress(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetBalancesByWalletAddressDocument);
        const result = await this.client.query({
            variables: queryVariables,
            query: query,
        });
        const walletByAddress = result?.data?.[userChain]?.walletByAddress;
        if (!walletByAddress?.tokenBalances?.length) {
            // Address can still be valid address, but not have any balances
            const address = walletByAddress?.address || '';
            const ensName = walletByAddress?.ensName || '';
            return {
                address: address,
                ensName: ensName,
                results: [],
                pageInfo: emptyPageInfo,
            };
        }
        const formattedResult = formatQueryResult(walletByAddress, 'tokenBalances', 'tokenBalancesPageInfo', null, this.flattenBalanceResponses // Remove the "contract" key and move info to balance result body
        );
        return formattedResult;
    }
    flattenBalanceResponses(response) {
        const modifiedResults = response.results.map((result) => {
            const { contract: { ...contractInfo }, ...balanceInfo } = result;
            return { ...balanceInfo, ...contractInfo };
        });
        response.results = modifiedResults;
        return response;
    }
}
__decorate([
    ValidateInput(balancesByWalletAddressValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TokensController.prototype, "getBalancesByWallet", null);

export { TokensController };
