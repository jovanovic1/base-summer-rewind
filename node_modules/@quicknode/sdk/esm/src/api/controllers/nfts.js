import { __decorate, __metadata } from 'tslib';
import { walletByAddressValidator } from '../types/nfts/getByWalletAddress.js';
import { nftDetailsValidator } from '../types/nfts/getNFTDetails.js';
import { nftCollectionDetailsValidator } from '../types/nfts/getCollectionDetails.js';
import { nftTrendingCollectionsValidator } from '../types/nfts/getTrendingCollections.js';
import { nftsByContractAddressValidator } from '../types/nfts/getByContractAddress.js';
import { verifyOwnershipValidator } from '../types/nfts/verifyOwnershipByAddress.js';
import { CodegenEthMainnetWalletNFTsByEnsDocument, CodegenEthMainnetWalletNFTsByAddressDocument, CodegenEthMainnetTrendingCollectionsDocument, CodegenEthMainnetWalletNFTsByContractAddressDocument, CodegenEthMainnetNFTDetailsDocument, CodegenEthMainnetNftCollectionDetailsDocument, CodegenEthMainnetVerifyOwnershipByAddressDocument, CodegenEthMainnetVerifyOwnershipByENSDocument } from '../graphql/generatedTypes.js';
import { formatQueryResult } from '../utils/postQueryFormatter.js';
import { emptyPageInfo } from '../utils/helpers.js';
import { DEFAULT_CHAIN } from '../utils/constants.js';
import { isValidENSAddress } from '../utils/isValidENSAddress.js';
import { ValidateInput } from '../../lib/validation/ValidateInput.js';
import { modifyQueryForChain } from '../graphql/modifyQueryForChain.js';

class NftsController {
    constructor(client, defaultChain = DEFAULT_CHAIN) {
        this.client = client;
        this.defaultChain = defaultChain;
    }
    async getByWallet(variables) {
        const { address, ...allVariables } = variables;
        if (isValidENSAddress(address)) {
            return this.getByWalletENS({
                ensName: address,
                ...allVariables,
            });
        }
        return this.getByWalletAddress({
            address,
            ...allVariables,
        });
    }
    async getByWalletENS(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetWalletNFTsByEnsDocument);
        const result = await this.client.query({
            query: query,
            variables: queryVariables,
        });
        const walletByENS = result?.data?.[userChain]?.walletByENS;
        if (!walletByENS?.walletNFTs?.length) {
            // Address can still be valid ENS name, but not have any NFTs
            const address = walletByENS?.address || '';
            const ensName = walletByENS?.ensName || '';
            return {
                address: address,
                ensName: ensName,
                results: [],
                pageInfo: emptyPageInfo,
            };
        }
        const formattedResult = formatQueryResult(walletByENS, 'walletNFTs', 'walletNFTsPageInfo', 'nft');
        return formattedResult;
    }
    async getByWalletAddress(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetWalletNFTsByAddressDocument);
        const result = await this.client.query({
            query: query,
            variables: queryVariables,
        });
        const walletByAddress = result?.data?.[userChain]?.walletByAddress;
        if (!walletByAddress?.walletNFTs?.length) {
            const address = walletByAddress?.address || '';
            const ensName = walletByAddress?.ensName || '';
            return {
                address: address,
                ensName: ensName,
                results: [],
                pageInfo: emptyPageInfo,
            };
        }
        const formattedResult = formatQueryResult(walletByAddress, 'walletNFTs', 'walletNFTsPageInfo', 'nft');
        return formattedResult;
    }
    async getTrendingCollections(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetTrendingCollectionsDocument);
        const result = await this.client.query({
            query: query,
            variables: queryVariables,
        });
        const chainResult = result?.data?.[userChain];
        if (chainResult?.trendingCollections?.length) {
            const formattedResult = formatQueryResult(chainResult, 'trendingCollections', 'trendingCollectionsPageInfo', 'collection');
            return formattedResult;
        }
        return {
            results: [],
            pageInfo: emptyPageInfo,
        };
    }
    async getByContractAddress(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetWalletNFTsByContractAddressDocument);
        const result = await this.client.query({
            query: query,
            variables: queryVariables,
        });
        const collection = result?.data?.[userChain]?.collection;
        if (!collection?.nfts?.length) {
            return {
                standard: null,
                results: [],
                pageInfo: emptyPageInfo,
            };
        }
        const setErcStandard = (results) => {
            const standardMap = {
                ERC1155Collection: 'ERC1155',
                ERC721Collection: 'ERC721',
            };
            // Remove address too since it was only used as a key field
            const { __typename, address, ...newResults } = results;
            return {
                ...newResults,
                standard: standardMap[results['__typename']] || null,
            };
        };
        const formattedResult = formatQueryResult(collection, 'nfts', 'nftsPageInfo', null, setErcStandard);
        return formattedResult;
    }
    async getNFTDetails(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetNFTDetailsDocument);
        const result = await this.client.query({
            query,
            variables: queryVariables,
        });
        const nft = result?.data?.[userChain]?.nft;
        if (nft)
            return { nft };
        return { nft: null };
    }
    async getCollectionDetails(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetNftCollectionDetailsDocument);
        const result = await this.client.query({
            query: query,
            variables: queryVariables,
        });
        const collection = result?.data?.[userChain]?.collection;
        if (collection)
            return { collection };
        return { collection: null };
    }
    async verifyOwnership(variables) {
        const { address, ...allVariables } = variables;
        if (isValidENSAddress(address)) {
            return this.verifyOwnershipByENS({
                ensName: address,
                ...allVariables,
            });
        }
        return this.verifyOwnershipByAddress({
            address,
            ...allVariables,
        });
    }
    async verifyOwnershipByAddress(variables) {
        const { chain, address, nfts } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetVerifyOwnershipByAddressDocument);
        const result = await this.client.query({
            query: query,
            variables: { address, filter: { contractTokens: nfts } },
        });
        const walletNFTs = result?.data?.[userChain]?.walletByAddress?.walletNFTs;
        return !!walletNFTs?.length;
    }
    async verifyOwnershipByENS(variables) {
        const { chain, ensName, nfts } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetVerifyOwnershipByENSDocument);
        const result = await this.client.query({
            query: query,
            variables: { ensName, filter: { contractTokens: nfts } },
        });
        const walletByENS = result?.data?.[userChain]?.walletByENS?.walletNFTs;
        return !!walletByENS?.length;
    }
}
__decorate([
    ValidateInput(walletByAddressValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NftsController.prototype, "getByWallet", null);
__decorate([
    ValidateInput(nftTrendingCollectionsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NftsController.prototype, "getTrendingCollections", null);
__decorate([
    ValidateInput(nftsByContractAddressValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NftsController.prototype, "getByContractAddress", null);
__decorate([
    ValidateInput(nftDetailsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NftsController.prototype, "getNFTDetails", null);
__decorate([
    ValidateInput(nftCollectionDetailsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NftsController.prototype, "getCollectionDetails", null);
__decorate([
    ValidateInput(verifyOwnershipValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NftsController.prototype, "verifyOwnership", null);

export { NftsController };
