import { __decorate, __metadata } from 'tslib';
import { contractEventsValidator } from '../types/events/getByContract.js';
import { collectionEventsValidator } from '../types/nfts/getCollectionEvents.js';
import { nftEventsValidator } from '../types/nfts/getNFTEvents.js';
import { allEventsValidator } from '../types/events/getAll.js';
import { CodegenEthereumMainnetEventsByContractDocument, CodegenEthMainnetEventsByCollectionDocument, CodegenEthereumMainnetEventsByNftDocument, CodegenEthereumMainnetEventsGetAllDocument } from '../graphql/generatedTypes.js';
import { formatQueryResult } from '../utils/postQueryFormatter.js';
import { emptyPageInfo } from '../utils/helpers.js';
import { DEFAULT_CHAIN } from '../utils/constants.js';
import { ValidateInput } from '../../lib/validation/ValidateInput.js';
import { modifyQueryForChain } from '../graphql/modifyQueryForChain.js';

class EventsController {
    constructor(client, defaultChain = DEFAULT_CHAIN) {
        this.client = client;
        this.defaultChain = defaultChain;
    }
    async getByContract(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthereumMainnetEventsByContractDocument);
        const result = await this.client.query({
            query: query,
            variables: queryVariables,
        });
        const contract = result?.data?.[userChain]?.contract;
        if (!contract?.tokenEvents?.length) {
            return {
                results: [],
                pageInfo: emptyPageInfo,
            };
        }
        const formattedResult = formatQueryResult(contract, 'tokenEvents', 'tokenEventsPageInfo');
        return formattedResult;
    }
    async getByNFTCollection(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetEventsByCollectionDocument);
        const result = await this.client.query({
            query: query,
            variables: queryVariables,
        });
        const collection = result?.data?.[userChain]?.collection;
        if (!collection?.tokenEvents?.length)
            return { results: [], pageInfo: emptyPageInfo };
        function removeKeyFields(results) {
            const { address, ...newResults } = results;
            return newResults;
        }
        const formattedResult = formatQueryResult(collection, 'tokenEvents', 'tokenEventsPageInfo', null, removeKeyFields);
        return formattedResult;
    }
    async getByNFT(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthereumMainnetEventsByNftDocument);
        const result = await this.client.query({
            query: query,
            variables: queryVariables,
        });
        const nft = result?.data?.[userChain]?.nft;
        if (!nft?.tokenEvents?.length)
            return { results: [], pageInfo: emptyPageInfo };
        function removeKeyFields(results) {
            const { contractAddress, tokenId, ...newResults } = results;
            return newResults;
        }
        const formattedResult = formatQueryResult(nft, 'tokenEvents', 'tokenEventsPageInfo', null, removeKeyFields);
        return formattedResult;
    }
    async getAll(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthereumMainnetEventsGetAllDocument);
        const result = await this.client.query({
            query: query,
            variables: queryVariables,
        });
        const events = result?.data?.[userChain];
        if (events?.tokenEvents?.length) {
            const formattedResult = formatQueryResult(events, 'tokenEvents', 'tokenEventsPageInfo');
            return formattedResult;
        }
        return { results: [], pageInfo: emptyPageInfo };
    }
}
__decorate([
    ValidateInput(contractEventsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], EventsController.prototype, "getByContract", null);
__decorate([
    ValidateInput(collectionEventsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], EventsController.prototype, "getByNFTCollection", null);
__decorate([
    ValidateInput(nftEventsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], EventsController.prototype, "getByNFT", null);
__decorate([
    ValidateInput(allEventsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], EventsController.prototype, "getAll", null);

export { EventsController };
