import { __decorate, __metadata } from 'tslib';
import { DEFAULT_CHAIN } from '../utils/constants.js';
import { transactionsBySearchValidator } from '../types/transactions/getBySearch.js';
import { transactionsByHashValidator } from '../types/transactions/getByHash.js';
import { CodegenEthMainnetTransactionsByWalletAddressDocument, CodegenEthMainnetTransactionsByWalletENSDocument, CodegenEthMainnetTransactionsBySearchDocument, CodegenEthMainnetTransactionsByHashDocument } from '../graphql/generatedTypes.js';
import { emptyPageInfo } from '../utils/helpers.js';
import { formatQueryResult } from '../utils/postQueryFormatter.js';
import { isValidENSAddress } from '../utils/isValidENSAddress.js';
import { ValidateInput } from '../../lib/validation/ValidateInput.js';
import { balancesByWalletAddressValidator } from '../types/tokens/getBalancesByWalletAddress.js';
import { modifyQueryForChain } from '../graphql/modifyQueryForChain.js';

class TransactionsController {
    constructor(client, defaultChain = DEFAULT_CHAIN) {
        this.client = client;
        this.defaultChain = defaultChain;
    }
    async getByWallet(variables) {
        const { address, ...allVariables } = variables;
        let queryResult;
        if (isValidENSAddress(address)) {
            queryResult = await this.getByWalletENS({
                ensName: address,
                ...allVariables,
            });
        }
        else {
            queryResult = await this.getByWalletAddress({
                address,
                ...allVariables,
            });
        }
        if (!queryResult?.transactions?.length) {
            // Address can still be valid address, but not have any transactions
            const address = queryResult?.address || '';
            const ensName = queryResult?.ensName || '';
            return {
                address: address,
                ensName: ensName,
                results: [],
                pageInfo: emptyPageInfo,
            };
        }
        const formattedResult = formatQueryResult(queryResult, 'transactions', 'transactionsPageInfo');
        return formattedResult;
    }
    async getByWalletAddress(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetTransactionsByWalletAddressDocument);
        const result = await this.client.query({
            variables: queryVariables,
            query: query,
        });
        const walletByAddress = result?.data?.[userChain]?.walletByAddress;
        return walletByAddress;
    }
    async getByWalletENS(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetTransactionsByWalletENSDocument);
        const result = await this.client.query({
            variables: queryVariables,
            query: query,
        });
        const walletByENS = result?.data?.[userChain]?.walletByENS;
        return walletByENS;
    }
    async getAll(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetTransactionsBySearchDocument);
        const result = await this.client.query({
            variables: queryVariables,
            query: query,
        });
        const transactions = result?.data?.[userChain];
        if (transactions && transactions?.transactions?.length > 0) {
            const formattedResult = formatQueryResult(transactions, 'transactions', 'transactionsPageInfo');
            return formattedResult;
        }
        return {
            results: [],
            pageInfo: emptyPageInfo,
        };
    }
    async getByHash(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = modifyQueryForChain(userChain, CodegenEthMainnetTransactionsByHashDocument);
        const result = await this.client.query({
            variables: queryVariables,
            query: query,
        });
        const transaction = result?.data?.[userChain];
        if (transaction?.transaction)
            return transaction;
        return { transaction: null };
    }
}
__decorate([
    ValidateInput(balancesByWalletAddressValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TransactionsController.prototype, "getByWallet", null);
__decorate([
    ValidateInput(transactionsBySearchValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TransactionsController.prototype, "getAll", null);
__decorate([
    ValidateInput(transactionsByHashValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TransactionsController.prototype, "getByHash", null);

export { TransactionsController };
